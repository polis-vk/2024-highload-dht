## Этап 1
При одновременном запуске wrk2 и async-profiler мой сервер выдерживает нагрузку в 6500 rps на GET запросы
и 22000 rps на POST запросы \
(точка разладки - 8000 и 25000 rps соответственно).
Нагрузочное тестирование проводилось в 1 поток и 1 соединение

### Получились следующие результаты
#### Результаты работы wrk2:
[get_6500rps.txt](wrk%2Fresults%2Fget_6500rps.txt) \
[put_22000rps.txt](wrk%2Fresults%2Fput_22000rps.txt)

#### Результаты работы async-profiler:
[get_alloc.png](asprof%2Fget_alloc.png) \
_Видно, что аллокации распределены более-менее равномерно; вероятно, тут ничего оптимизировать не надо_

[get_cpu.png](asprof%2Fget_cpu.png) \
_Здесь можно увидеть, что значительную часть процессорного времени (45%) занимает метод ```memorySegment.mismatch()```. \
Проанализировав свой код, я не нашел мест, где от вызова этого метода можно было бы избавиться_

[put_alloc.png](asprof%2Fput_alloc.png) \
_Тут аллокации тоже почти равномерные, однако выделяется ```byte[]``` внутри one.nio read \
Я не думаю, что могу как-то уменьшить там число аллокаций_

[put_cpu.png](asprof%2Fput_cpu.png) \
_Основная часть времени уходит на read, write и kevent из one.nio \
Возможно, можно сократить затраты процессорного времени, более тонко настроив сервер в one.nio_

