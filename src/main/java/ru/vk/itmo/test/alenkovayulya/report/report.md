Директория cringe_results - история про то, как не заметить ошибки в скриптах и все замерить неправильно...
Обнаружила я, что мои запросы не выполняются, а просто откидываются, только на этапе профилирования, когда увидела вызов метода handleDefault класса ServerIml вместо работы с дао)))
Поэтому, очевидно, выдерживаемую нагрузку и точки разладки пришлось измерять заново

Все корректные данные лежат в директории right_results 

Точки разладки я определеяла, постепенно давая большую нагрузку и следя за персентилями.

Для PUT-запросов анализ выглядел следующим образом:

**PUT 25K RPS**
50.000%    1.08ms
75.000%    1.79ms
90.000%    2.74ms
99.000%    5.39ms
99.900%   14.48ms
99.990%   18.22ms
99.999%   18.54ms
100.000%   18.61ms

**PUT 30K RPS**
50.000%  701.00us
75.000%    1.03ms
90.000%    1.98ms
99.000%    5.51ms
99.900%   21.26ms
99.990%   26.51ms
99.999%   26.99ms
100.000%   27.04ms

**PUT 35K RPS**
50.000%  665.00us
75.000%    0.98ms
90.000%    1.37ms
99.000%   17.26ms
99.900%   37.85ms
99.990%   42.43ms
99.999%   42.81ms
100.000%   42.85ms

Можно заметить, как постпененно серверу становится хуже и хужи, и вот мы подходим к точке разладки: 

**PUT 40K RPS**
50.000%  921.60ms
75.000%    1.16s
90.000%    1.21s
99.000%    1.25s
99.900%    1.25s
99.990%    1.25s
99.999%    1.25s
100.000%    1.25s

Таким образом, за стабильную нагрузку ниже точки разладки я приняла 20 000 rps и провела двухминутный тест:

50.000%    1.41ms
75.000%    2.03ms
90.000%    2.63ms
99.000%    4.53ms
99.900%   14.22ms
99.990%   20.16ms
99.999%   21.63ms
100.000%   22.35ms

Получила адекватные персентили и среднюю Latency = 1.52ms 

Для GET-запросов, так как LSM на чтение работает медленее, чем на вставку, выдерживаемая нагрузка оказалась поменьше:

**GET 10K RPS**
50.000%    1.06ms
75.000%    1.66ms
90.000%    2.18ms
99.000%    2.60ms
99.900%    6.24ms
99.990%    9.87ms
99.999%   10.04ms
100.000%   10.06ms

**GET 20K RPS** - уже здесь можно заметить сильное ухуджение
50.000%    0.86ms
75.000%    1.36ms
90.000%    2.20ms
99.000%    6.82ms
99.900%   33.05ms
99.990%   39.20ms
99.999%   39.77ms
100.000%   39.81ms

**GET 40K RPS**
50.000%   13.36s
75.000%   14.06s
90.000%   14.31s
99.000%   14.36s
99.900%   14.37s
99.990%   14.37s
99.999%   14.37s
100.000%   14.37s

Стабильной нагрузкой я посчитала 10K и также проверила сервер под ней в течение двух минут:

50.000%    1.11ms
75.000%    1.73ms
90.000%    2.18ms
99.000%    4.03ms
99.900%   11.73ms
99.990%   21.25ms
99.999%   22.25ms
100.000%   22.56ms

Latency     1.23ms 

**Результаты профилирования**
ALLOC GET/ALLOC PUT
На графиках заметно, что больше всего аллокаций приходится на работу библиотеки one nio, связанную с преобразованиями входных и выходных данных 
Также значимая часть аллокаций - на преобразование ключей и значений в MemorySegment и обратно

CPU GET/CPU PUT
Для поиска,стоит отметить работу метода get нашего Dao, в котором большую часть времени тратилось на бинарный поиск.
Для вставкт, соответсвенно, метод upsert того же Dao. 
Также для обоих методов большое кол-во времени тратится на работу библиотеки one-nio по процессингу запросов и отправке ответов и внутренние джавовские процессы










