# Отчет 1 (Шеметов Алексей, ИТМО ФИТиП)

## PUT

### Поиск стабильной нагрузки

Данные для создания запросов буду генерировать с помощью [put.lua](./wrk/put.lua).

Каждый раз запуск происходил на пустой БД.

Поймем, какой параметр `-R` нужен, чтобы обеспечить стабильную нагрузку на сервер.

- R = 30000
    - `wrk2 -t1 -c1 -d30 -R30000 -s put.lua -L http://localhost:8080`
    - Avg Latency = `597.17us`, Requests/sec: `29999.23`

- R = 35000
    - `wrk2 -t1 -c1 -d30 -R35000 -s put.lua -L http://localhost:8080`
    - Avg Latency = `639.13us`, Requests/sec: `34999.14`

- R = 37500
    - `wrk2 -t1 -c1 -d30 -R37500 -s put.lua -L http://localhost:8080`
    - Avg Latency = `0.87ms`, Requests/sec: `37498.99`

- R = 40000
    - `wrk2 -t1 -c1 -d30 -R40000 -s put.lua -L http://localhost:8080`
    - Avg Latency = `1.93ms`, Requests/sec: `39995.63`


__R = 37500__ что-то вроде порогового значения, так как после его увеличения, Avg Latency сильно возрастает и нагрузка перестает быть _стабильной_.

График зависимости Avg Latency от кол-ва запросов:

![](./img/put-hist.png)

`87.5%` запросов при __R = 37500__ имеюют latency не превосходящий `1.396ms`, что обеспечивает стабильную нагрузку.

### CPU

#### Общий взгляд

Посмотрим на общую CPU-нагрузку при __R=37500__:

![](./img/cpu37500.png)

- `93%`: `SelectorThread`, который считывает данные и записыват их обратно
    - `48%`: Selector
    - `44%`: Session process - общее время работы нашей сессии
      - `24,5%`: putById - время работы put
      - `18%`: Session read - время чтения нашего результата
- `7%`: фоновые методы

![](./img/cpu_method.png)

Если смотреть на работу самого метода, то можно уже заметить, что основное время работы тратиться на сравнение сегментов и их запись на диск

### ALLOC

Посмотрим на выделении памяти при __R=37500__:

![](./img/allocate.png)

- `95%`: `SelectorThread`
    - `38%` уходит на перевод строки в байты при чтении входного запроса `HttpSession` - это особенность HTTP-запросов, и кажется это сложно улучшить, так как HTTP - текстовый протокол, поэтому парсинга не избежать. Однако в нашем случае можно было бы сократить кол-во парсинга, учитывая, что мы кладем именно байты в базу.
    - `12%` уходит каждый раз на создани объекта `Response` вызовом метода `created`. Можно заранее создать статические переменные, но тогда надо не забыть переписать `HttpSession`, в частности метод `sendResponse(response)`, который к каждому ответу дописывает лишние хедера вида `"Connection: Keep-Alive"` or `"Connection: close"`.
    - `16%` уходит на запись в `Dao`

## GET

Буду искать стабильную нагрузку при наполненной БД примерно `2,4Gb` с помощью скрипта [get.lua](./wrk/get.lua).
Для заполнения ипользовал скрипт [putg.lua](./wrk/putg.lua)
Использовал flushThresholdBytes = `4Mb` в моем случае влияет только на то, как часто мы будем брать из памяти.
Забегая вперед из памяти 3 samples, а из файликов 1194 samples

### Поиск стабильной нагрузки

- R = 5000
    - `wrk2 -t1 -c1 -d30 -R5000 -s get.lua -L http://localhost:8080`
    - Avg Latency = `1.36s`, Requests/sec: `4999.83`
- R = 4500
    - `wrk2 -t1 -c1 -d30 -R4500 -s get.lua -L http://localhost:8080`
    - Avg Latency = `204.87ms`, Requests/sec: `4417.12`
- R = 4000
    - `wrk2 -t1 -c1 -d30 -R4000 -s get.lua -L http://localhost:8080`
    - Avg Latency = `848.35us`, Requests/sec: `3999.90`

+- нормальная нагрузка получается при __R=4000__.

### CPU

#### Общая нагрузка

Посмотрим на общую CPU-нагрузку при __R=4000__:

![](./img/cpu_get4000.png)

нагрузка +- распределена так же как и в случае с `put`, за исключеним того, что теперь у нас увеличелось время чтения. Что ожидаемо!

### ALLOC

![](./img/alloc_get4000.png)

снова ситуация аналогичная `put`

## Выводы

Методы `PUT` и `GET` на графиках показали примерно одинаковое поведение, за исключением "эффективности работы". У `PUT` хороший Avg Latency 
достигается при больших кол-во запросах, по сравнению с `GET`. Скорее всего, причиной является то, что нам приходится довольно часто искать данные в различных файлах (смотрим не только файл с номером 1)
`+` в каждом из них еще и применяем бин поиск, в следствии чего и получаем довольно большое время на поиск нужного значения. В `PUT` же
мы такими вещами не занимаемся
С памятью особо проблем не наблюдалось, раз только в создание одних и тех же Response, но в дальнейшем с распаралеливанием сервера, 
нагрузка станет больше и эти аллокации скорее всего не так сильно будут влиять на память, поэтому сейчас это скорее ок.
Да и в общем хочется сказать, что на данном этапе формально все проблемы врезаются в проблемы использования http, 
так как опять же на данном этапе мы не делает ничего сверхестественного