## Нагрузочное тестирование
Тестирование проводил на одной машине в одной среде. Сервер и wrk/async запускались рядом.
JVM была прогрета запросами. Тестировал на одной ноде.
Процессор - i7-10510U.

В рамках данного этапа был реализован эндпоинт с range запросом на get entities.

## Наполнение базы данных
Было сгенерировано с помощью WRK ~200MB данных. Это 2.500.000 записей.
1. Первая нода - 25 SSTables

### RANGE GET
С помощью CURL я отправлял запросы на get from 0 to 2.500.000. Также, параллельно запускал эти CURL'ы.
Среднее время ответа на один curl запрос для 2.500.000 записей - 20 секунд, при каждом последующем параллельном запросе
время ответа увеличивалось пропорционально, т.е, 2 запроса - 40 секунд, три запроса - 60 секунд.

### async-profiler
#### CPU
95% процессорного времени занимает writeChunk метод. Из которого 94% это Session.write(), а оставшийся процент - это
перевод в hex string. 3% это MergeIterator, 1% GC.

#### ALLOC
Аллок у меня всё также выедает GC. Я думал, что исправил проблему с выеданием памяти, так как тесты перестали флакать. Видимо,
проблема была не в CompletableFuture, и нужно сидеть копать, что находится в памяти JVM и почему GC так много работает.
Возможно, для range запроса это нормально, что GC так много работает, ведь мы перемалываем 2.500.000 записей, и понятное дело,
что нам их нужно удалять из памяти?

#### LOCK
Отчеты на lock у меня почему-то не отрабатывают, пытался давать права через sysctl, включал опцию в JVM на dynamic agent, 
но всё равно локи он почему-то не показывает :\. Также, запускал запросы на range get параллельно, чтобы отрабатывало N количество
запросов параллельно, но локи всё равно не появились.

### Выводы
Интересно было узнать про chunked передачу данных через HTTP протокол, не знал о таком. Также, всё ещё не понимаю проблему
такой усердной работы GC. Я думал, что проблема была в CompletableFutures и вроде как пофиксил это, тесты перестали флакать на агенте.
Но всё равно, в этой лабораторной работе вижу, что GC забирает 97% аллоков в системе. Возможно, это нормально, для range запроса?
Либо проблема всё же была не в CompletableFutures (хотя GC начал так работать именно после этого этапа), а в чём-то другом.

Сами range get запросы отрабатывают правильно, и вроде бы как, хорошо. Мне кажется, что для этой машины вернуть 2.500.000 запросов из
диска за 20 секунд - неплохой результат.

##### Результаты
Посмотреть результаты async-profiler: src/main/java/ru/vk/itmo/test/asvistukhin/reports/async_profiler/lab6
Скрипты для генерации wrk запросов: src/main/java/ru/vk/itmo/test/asvistukhin/reports/wrk_script