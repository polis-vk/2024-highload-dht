# Отчёт по модулю 2
## Наполнение
Наполнения производилось скриптом, аналогичным используемому
в модуле 1, общий объём данных составил ~6.6 GiB, количество
SSTable = 377

## Профилирование на запись
Профилирование производилось при нагрузке в 12'000 RPS
(точка разладки ~15'000 RPS), 1 поток, 64 соединения

[Логи wrk2 на запись](wrk_put.txt)

### ЦПУ
[Профиль ЦПУ на запись](profile_write_cpu.html)

Профили ЦПУ не изменились, за исключением разделения функций получения данных
и их обработки в разные потоки

### Аллокации
[Профиль аллокаций на запись](profile_write_alloc.html)

Появились дополнительные аллокации, необходимые для 
обслуживания очереди запросов
(н-р, ConditionNode), которые по некоторым потокам занимают
до трети всей аллоцируемой памяти.

### Блокировки
[Профиль блокировок на запись](profile_write_lock.html)

Появились блокировки очереди потоков, которые и составляют подавляющее большинство.

## Профилирование на чтение

Нагрузка при работе на чтение производилось скриптом, аналогичным используемому
для тех же задач в предыдущем модуле (50% ключей существуют, 50% - нет)

Профилирование производилось при нагрузке в 7'500 RPS (точка разладки ~9'000RPS),
8 потоков, 1024 подключения

[Логи wrk2 на чтение](wrk_get.txt)

### ЦПУ 

[Профиль ЦПУ на чтение](profile_read_cpu.html)

Профили ЦПУ не изменились, за исключением разделения функций получения данных и их обработки в разные потоки

### Аллокации

[Профиль аллокаций на чтение](profile_read_alloc.html)

В профилях ЦПУ появились аллокации под лямбда-функции.

### Блокировки

[Профиль блокировок на чтение](profile_read_lock.html)

Блокировки связаны с вводом-выводом, которые появились, 
теперь запросы исполняются в разных потоках, и ответ на более поздний запрос может быть 
готов к отправке раньше, чем на более ранний, пришедший в рамках того же запроса.

# Замена ArrayBlockingQueue на SynchronousQueue

Тесты на wrk2 проводятся при тех же или более "трудных" условиях.

[Логи wrk2 на чтение](wrk_get_synchronous_queue.txt)

[Логи wrk2 на запись](wrk_put_synchronous_queue.txt)

Заметен прирост по всем перцентилям 

Будем рассматривать только те изменения профили, по которым есть заметные изменения

# Запись

[Профиль ЦПУ на запись](profile_write_cpu_sync_q.html)

Основное отличие по ЦПУ - снижение объема работы GC.
Можно заметить снижение обработки блокировок очереди при добавлении в очередь.

# Чтение 
[Профиль блокировок на чтение](profile_read_alloc_sync_q.html)

Можно заметить, что очередь больше не блокируется, остались лишь сетевые блокировки.


# WRED-вдохновленная очередь

Результатов, достойных упоминания, не принесла)

Связано это в первую очередь с неоптимальностью использования связного списка
для подобных очередей с сильно ограниченным (если не сказать константным) размером.

Тем более в условиях, когда себя очень хорошо проявляет SynchronousQueue.

---

### Заметка на полях

Надо будет попробовать реализовать ArrayBlockingDequeue и уже на нем попробовать снова
