## Производительность

- **PUT Запросы:**

  | Запрос | lab3    | lab4    | lab5    |
    |--------|---------|---------|---------|
  | rps    | 35000   | 14500   | 17000   |
  | avg    | 15.85ms | 68.08ms | 45.28ms |
  | Stdev  | 29.97ms | 40.66ms | 33.32ms |

  Произошло снижение производительности примерно на `~17%` и уменьшение задержки на `~30%`.

- **GET Запросы:**

  | Запрос | lab3    | lab4    | lab5    |
    |--------|---------|---------|---------|
  | rps    | 40000   | 14500   | 18000   |
  | avg    | 17.40ms | 96.85ms | 63.81ms |
  | Stdev  | 20.24ms | 42.12ms | 34.65ms |

  Произошло снижение производительности примерно на `~24%` и уменьшение задержки на `~30%`.

## Профилирование

### PUT

В процессе профилирования были обнаружены следующие изменения:
- **CPU**: Класс `CompletableFuture` занимает `~15%` от общего времени CPU. Это связано с тем, что запросы теперь
  обрабатываются асинхронно.
- **ALLOC**: `CompletableFuture` занимает `~33%` от общего объема выделенной памяти. Это связано с созданием новых
  экземпляров `CompletableFuture` для каждого асинхронного запроса.
- **LOCK**: `~37%` времени занимают операции с блокировками, связанные с обработкой `CompletableFuture`.

### GET

Аналогичные изменения наблюдаются и при обработке GET запросов:
- **CPU**: В процессе выполнения запросов появился новый класс `CompletableFuture`, который занимает `~12%` от общего
времени CPU. Это связано с тем, что теперь запросы обрабатываются асинхронно.
- **ALLOC**: Класс `CompletableFuture` также заметно влияет на распределение памяти. Он занимает `~28%` от общего объема 
выделенной памяти.
- **LOCK**: `~30%` времени занимают операции с блокировками, связанные с обработкой `CompletableFuture`.

## Выводы

При использовании `CompletableFuture` для асинхронной обработки запросов, мы смогли добиться некоторого увеличения 
производительности. Это связано с тем, что запросы теперь обрабатываются
параллельно, и клиент не должен ждать завершения всех запросов, что приводит к уменьшению задержки.