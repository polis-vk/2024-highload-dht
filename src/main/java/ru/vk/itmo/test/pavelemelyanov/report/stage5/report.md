# Отчёт stage2
Всвязи с тем, что ноутбук, на котором я делал первые лабы вышел из строя
(бесконечная загрузка). Протестировал на стационарном компьюетре с оооооочень плохими характеристиками (у меня он винду не тянет вообще никак)
Всего ядер 2, так как процессор слудующий: intel(r) core(tm) i3-6100t cpu
поэтому значения параметров в отчёте крайне маленькие
Кластер состоит из 3 нод
При увеличении количества соединений возникали проблемы с тестированием, так как компьютер не справлялся
# Анализ
Точка разладки достигается при 1000 rps на put и при 2к на get, поэтому буду тестировать на 700 rps put и 1500 get

## Alloc PUT
Появилась аллокация ForkJoinWorkerThread.run, которая возникла, подозреваю при работе с CompletableFuture

Не понимаю, почему нет аллокации на дэфолтный экзекутор. По идее он должен быть, ведь сам я его не создавал

## Alloc GET
Аналогично, но с изменением в пропорциях

## Lock PUT
ThreadPoolExecutor.runWorker занимает 73%
ThreadPoolExecutor.getTask - 8%
CompletableFuture$AsyncSupply.run 19.62%
SequentialScheduler$SchedulableTask.run - 45%
SelectorManager - 20% 
Подозреваю, что такие значения из-за асинхронной работы
## Lock GET
Аналогично, но с изменением в пропорциях
## CPU PUT
SelectorManager занимает 5% (используется для управления соединениями клиента)
Появилась работа у воркеров с CompletableFuture, чего мы и добивались

Работа с responseAsync клиента - 35%; в нем же 25% - работа СompletableFuture
## CPU GET
Аналогично, но с изменением в пропорциях
## Итог
Из-за CompletableFuture выросла трата ресуросв на работу с ними. Самыми показательными были LOCK фреймы.

## Улучшения
- Идей нет