# Отчет по ДЗ 1

## Нагрзочное тестирование (Мытарство первое)

Первое нагрузочное тестирование проходило сразу после создания сервера.

Я прововал нагружать базу при разных настройках, но почти всегда результаты были настолько страшными,
что приходилось все уменьшать и уменьшать RPS в `wrk`. В голову закрадывались ужасные мысли по поводу того, на что я потратил весь прошлый семестр.

[lua скрипт для get запросов](../lua/get_sequence.lua)

[lua скрипт для put запросов](../lua/put_sequence.lua)

Отдавать хотя бы какие-то результаты база стала только на 10 RPS, при этом не падая через 2 минуты.

[Нагрузочное тестирование put при 10 RPS 120 секунд](wrk_put1.txt)

[Нагрузочное тестирование put при 10 RPS 120 секунд](wrk_get1.txt)

И тут я заметил, что в `get` запросах читается информации всего несколько килобайт, когда как в `put` это уже несколько мегабайт.

В голову приходит мысль, что такого не может быть, ведь `get` отдает значения из базы, а `put` всего лишь возвращает `OK`.

### Гипотеза: проблема с ответом put

Я начал смотреть, что может быть не так с `Response` в `one.nio`. Оказалось, что это не потокобезопасный класс,
а заголовки создаются при отправке. Скрипт на питоне с `requests` падал с ошибкой, что в ответе более 100 заголовков. 

### Новая версия

Исправленная версия создает ответ на запрос каждый раз. В итоге смог выбрать RPS 2000 для нагрузочного тестирования.
При 2000 rps база выдает еще более или менее стабильно быстрый результат. При больших нагрузках результат менее стабильный.



[Нагрузочное тестирование put при 2000 RPS 60 секунд](wrk_put2.txt)

[Нагрузочное тестирование put при 2000 RPS 60 секунд](wrk_get2.txt)

## Профилирование (Мытарство второе)

Проводим профилирование при нагрузке в 2000 RPS.

[Профилирование cpu get](profile_get_cpu1.html)

[Профилирование alloc get](profile_get_alloc1.html)

[Профилирование cpu put](profile_put_cpu1.html)

[Профилирование alloc get](profile_put_alloc1.html)


### Гипотеза: долго работает роутинг.

Практически все время занимает чтение и запись, 
но некоторое количество массивов байтов уходит именно в методе `handleRequest`

Профилирование с улучшенным роутингом:

[Профилирование cpu get](profile_get_cpu2.html)

[Профилирование alloc get](profile_get_alloc2.html)

[Профилирование cpu put](profile_put_cpu2.html)

[Профилирование alloc get](profile_put_alloc2.html)

При этом хочу заметить, что в нагрузочном тесте ничего не изменилось.

Судить по flame графам можно по тому, что не изменилось, а именно:

- Вызов метода `get` стал занимать 69 процентов вместо 49
- Вызов метода `put` стал занимать 30 процентов вместо 28

### Вывод

Мы выиграли по памяти немного, но это не было узким местом.



