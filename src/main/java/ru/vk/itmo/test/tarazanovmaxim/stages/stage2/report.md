# Таразанов Максим, ИТМО, М4139, Stage 2

*для начала хочу извиниться, что накосячил с веткой первого
стейджа и не отправил (как выяснилось), я её нормально сделаю чуть позже, пусть это не в счет баллов пойдёт.
Сравнение проводилось на другом железе (не на WSL, а на Ubuntu. Поэтому из-за смены ноута чуть позже 1й отчет загружу).*

## Executors
* **corePoolSize** выбрано так, чтобы брать примерно половину доступных серверных ядер.
Данный подход нужен для компромиса между высокой параллелизацией и 
избеганием лишнего контекстного переключения между потоками.
Плюсом остаются ресурсы на *некоторые другие задачи у сервера*;
 обозначает максимальное количество потоков в пуле, чтобы не создавать лишних;
* **keepAliveTime** = 0, чтобы уменьшить ресурсоёмкость при низкой нагрузке;
* **queueCapacity** кажется, что 100 нормально для того чтобы нормально работать и не реджектить лишнего;
* **AbortPolicy** -- реджект при переполнении.

## GET
Прошлая реализация держалась на [12000rps](..%2Fstage1%2Foutputs%2Fget_20s_12000.txt):
* передача **0.88МВ/с**;
* ср.латенси **2.455**.

### -t 1 -c 1
Новая реализация показывает ужасный результат на [12000rps](outputs%2Fget_20s_12000.txt):
* передача **0.56МВ/с**;
* латенси **!6110!**.

Может жить на [7000rps](outputs%2Fget_20s_7000.txt).

Одиночные запросы обрабатываются очень плохо :(

### -t 4 -c 128
[Значительно лучше](outputs%2Fget_20s_12000_128.txt)
* передача **0.89МВ/с**
* латенси **1.022** (меньше в 2.5 раза)

Параллельные запросы в совокупности улучшили работу сервера (:

## PUT
Прошлая реализация [90000rps](..%2Fstage1%2Foutputs%2Fput_20s_90000.txt):
* передача **5.75МВ/с**;
* латенси **52.58**.

### -t 1 -c 1
[Новый вариант](outputs%2Fput_20s_90000.txt) показал себя хуже (а вообще может жить на нагрузке в [1.5 раза меньше](outputs%2Fput_20s_60000.txt)):
* передача **3.76MB/с**;
* латенси **5127.906**.

### -t 4 -c 128
[Параллельные запросы](outputs%2Fput_20s_90000_128.txt) обрабатываются значительно лучше:
* передача **5.73MB/с**;
* латенси **0.906** (значительно лучше).

В разы лучше!

## Asprof
### CPU
Параллельные запросы позволяют серверу нагружаться в основном на работу с базой
Разгруженность сокетов улучшает работу

### Alloc
Появляются дополнительные затраты памяти на локи

### Lock
Чем больше воркеров - тем больше локов на их синхронизацию, 
что не очень хорошо и надо поменять очередь на локфри (например flatcombining), чтобы не сильно терять время на синхронизацию