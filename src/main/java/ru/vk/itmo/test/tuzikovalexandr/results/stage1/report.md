# Эксперименты с WRK: Анализ производительности и предложения по оптимизации 

## Эксперимент 1: PUT запросы (500 на протяжении 10 секунд)

Цель эксперимента: Первичное тестирование производительности через отправку данных с помощью wrk.

### Перцентили:
```
 50.000%    2.50ms
 75.000%    5.01ms
 90.000%   11.49ms
 99.000%   73.47ms
 99.900%  157.70ms
 99.990%  166.78ms
 99.999%  166.78ms
100.000%  166.78ms
```

Результаты:
- Время отклика на 90-ом перцентиле составило 11.49ms и значительно увеличилось до 73.47ms на 99-ом перцентиле, что указывает на возможные задержки в обработке запросов при высокой нагрузке.
- Возможная причина задержек – использование виртуализации.

## Эксперимент 2: PUT запросы (3000 на протяжении 30 секунд)

Увеличить количество запросов до 3000, а время до 30 секунд.

### Перцентили:
```
 50.000%    6.73ms
 75.000%   20.35ms
 90.000%   37.31ms
 99.000%  517.12ms
 99.900%  647.17ms
 99.990%  659.46ms
 99.999%  659.97ms
100.000%  659.97ms
```

Результаты:
- Наблюдается значительное увеличение времени на 99-ом перцентиле до 517.12ms, что говорит о замедлении работы сервера под высокой нагрузкой.
- Даже при увеличении нагрузки сервер справляется с обработкой запросов, однако время отклика значительно возрастает.

На 10000 также возрасло время, но почти 100% запросов были обработаны.

## Эксперимент 3: PUT запросы (25000 на протяжении 30 секунд)

### Перцентили:
```
 50.000%    4.27s 
 75.000%    6.35s 
 90.000%    6.98s 
 99.000%    7.22s 
 99.900%    8.26s 
 99.990%    8.36s 
 99.999%    8.37s 
100.000%    8.37s 
```

Особенности:
- На данном этапе время отклика на 50-ом перцентиле достигло уже 4.27s, что свидетельствует о серьезных проблемах с производительностью сервера под такой нагрузкой.
- Приблизительно 30% запросов не были обработаны в установленные временные рамки.

Далее на 3000 и 10000 запросов были сделаны графа для анализа нагрузки на CPU и просмотра аллокаций и будут ли какие-то изменения.

## Анализ Flame Graph (CPU и ALLOC для PUT запросов)

Файлы: put_profile_3000_cpu.html и put_profile_10000_cpu.html

Основные выводы:
- Большая часть ресурсов CPU затрачивается на работу виртуальной машины и обработку запросов.
- Выделение памяти (ALLOC) в значительной степени происходит при конвертации данных из MemorySegment в байтовые массивы.

### Flame Graph (ALLOC)

Файлы: put_profile_3000_alloc.html и put_profile_10000_alloc.html

## Эксперимент 1: GET запросы (500 на протяжении 10 секунд)

Для запросов GET также взять небольшие значения сначала.

### Перцентили:
```
 50.000%    2.11ms
 75.000%    3.26ms
 90.000%    5.96ms
 99.000%   20.13ms
 99.900%   39.26ms
 99.990%   43.78ms
 99.999%   43.78ms
100.000%   43.78ms
```

Скачок наблюдается в 99-ом прецентиле. Но ничего необычного вроде нет.

## Эксперимент 2: GET запросы (3000 на протяжении 30 секунд)

### Перцентили:
```
 50.000%   13.08ms
 75.000%   46.69ms
 90.000%   72.64ms
 99.000%  107.65ms
 99.900%  115.78ms
 99.990%  116.93ms
 99.999%  117.06ms
100.000%  117.12ms
```

## Эксперимент 3: GET запросы (25000 на протяжении 30 секунд)

### Перцентили:
```
 50.000%    8.75s
 75.000%   10.54s
 90.000%   11.21s
 99.000%   11.63s
 99.900%   11.65s
 99.990%   11.65s
 99.999%   11.65s
100.000%   11.65s
```

- Аналогично PUT запросам, с увеличением нагрузки наблюдается увеличение времени отклика, особенно на высоких перцентилях.
- Сервер продолжает справляться с увеличенной нагрузкой, хотя и с более высоким временем отклика.

### Flame Graph (CPU) для GET запросов

Файлы: get_profile_3000_cpu.html и get_profile_10000_cpu.html

Также как и при вставке данных, большая часть - обработка запроса.

### Flame Graph (ALLOC) для GET запросов

Файлы: get_profile_3000_alloc.html и get_profile_10000_alloc.html

Здесь основной момент аллокации происходит, когда для создания ответа нам необходимо из MemorySegment сделать массив байтов.

## Предложения по оптимизации

1. Избегание использования виртуальной машины: Непосредственное использование физического сервера может существенно снизить накладные расходы на виртуализацию и улучшить производительность.
2. Оптимизация настроек сервера: Ревизия и настройка конфигураций сервера может способствовать более эффективной обработке запросов.
3. Оптимизация работы со строками и данными: Рассмотрение возможности получения и обработки данных сразу в байтовом представлении может уменьшить нагрузку на процессор и время отклика за счет сокращения необходимых преобразований.