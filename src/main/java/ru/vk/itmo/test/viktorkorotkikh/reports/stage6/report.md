# Stage 6

- [Stage 6](#stage-6)
    * [Конфигурация](#Конфигурация)
    * [CPU profile](#cpu-profile)
    * [Alloc profile](#alloc-profile)
    * [Lock profile](#lock-profile)

## Конфигурация

Наполнение одной ноды - 1335Mb (1.3Gb). Все ключи имеют вид `key%d+`.

Запрос: `curl -vvv 'http://localhost:8080/v0/entities?start=key'`

## CPU profile

[RANGE-cpu.html](RANGE-cpu.html)

Почти все сэмплы занимает операция сдвига итераторов. Во время сдвига мы удаляем и добавляем итераторы обратно в очередь.
Каждая такая операция сопровождается сравнением ключей `MemorySegment`. Сравнения были заинлайнены компилятором. 
Сравнения также были оптимизированы с помощью векторных инструкций.

Из интересного - `MemorySegment::copy` использует avx512 при копировании данных в `ByteArrayBuilder`.

Такое количество сэмплов на операцию сдвига итераторов объясняется тем, что у нас дублируются данные в Sstable, поэтому 
нам приходится скипать ключи.

## Alloc profile

[RANGE-alloc.html](RANGE-alloc.html)

Аллокации невероятно красивые - всё, что нам приходится тут аллоцировать, так это `TimestampedEntry` (но без этого никак,
такой у нас интерфейс) и `MemorySegment`. При этом аллокации `MemorySegment` происходят лишь в методе 
`MergeIterator::next`, то есть при сдвигах итераторов мы не аллоцируем память, а сравниваем `MemorySegment`'ы прямиком 
на диске (а точнее скорее всего в page cache). Достойно уважения.

## Lock profile

[RANGE-lock.html](RANGE-lock.html)

Локи пустые. Блокирующих операций у нас действительно нет.
